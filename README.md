# Acoustic Sliding-Frank-Wolfe

## 1 - Basic intructions

To launch a given script, navigate to the project directory and run the script from the command line as a module.

**Example :**
``~/sfw$ python3 -m src.test_sfw``

To launch the automated tests: 

``~/sfw$ python3 -m unittest discover tests``

## 2 - Advanced usage

### Launching one or multiple source reconstructions
Simulations can be launched through the apply_sfw.py script, either directly or in command line:

``~/sfw$ python3 -m src.apply_sfw [--path=] [--exp=] [--exp_path]``

**Arguments :**
* path: directory where the results will be saved, should contain a parameters.json configuration file 
* exp_path: directory containing the room parameters in .json files
* exp: two integers separated by a comma that give the range of experience IDs that will be considered in the folder. Ex : 4,9 will apply SFW to the experiences 4 to 8.

The format of the configuration files and the scripts than can be used to create them are detailed below.

### Creating a configuration file for the room

A room file should respect the name "exp_i_param.json" where i is replaced by the room id number. There should be no gaps in the ids in order to use apply_sfw on the whole sequence.
The room file can either be created manually or the script sfw_experiment.py can be used to create random rooms. 
This last case is covered in the next session (recommanded to get a file template that can be modified afterwards).
Some parameters given can be ignored depending on a specific experiment configuration file. 

**Fields:**
* src_pos: array containing the source coordinates
* room_dim: array containing the room dimensions
* mic_pos: array containing the coordinates of the microphone array centered at (0,0,0), shape (M, 3)
* origin: location of the center of the microphone array in the room (ie mic_pos will be translated by +origin)
* absorptions: dictionary containing the walls' absorption coefficients. Example: {"north": 0.07, "south": 0.10, "east": 0.28, "west": 0.16, "floor": 0.15, "ceiling": 0.02}
* rotation_walls, rotation_mic (optional): arrays containing 3 angles for a rotation that will be applied to the microphone antenna before and after simulations in order to randomize the orientation of the antenna,
and shuffle the coordinate referential
### Using experiment_sfw.py to create random rooms

To use sfw_experiment.py, a parameters.json configuration file must be placed in the directory that will contain the room files.
This configuration file can be created by launching the script create_conf_file.py. The folder path should be updated in the file, 
and the boolean "room_param" set to True. The number of generated rooms can be changed in the file
The absorption coefficients are chosen uniformly in [0.01, 0.3].

**Fields:**
* xlim, ylim, zlim: set lower and upper bounds for the room length in each direction (picked using a uniform law)
* mic_size: scale factor applied to the radius of the eigenmike spherical antenna
* src_wall_sep, mic_wall_sep: minimal distance of the source/microphone antenna center to the walls (might cause a crash when the room is too small)
* z_src, z_mic: additional constrain to set a fixed z coordinate for the source/microphone antenna center (set to None to keep it random)

### Simulations configuration files

The folder that is chosen to contain the reconstruction results must contain a parameters.json configuration file that 
can be created manually or by using create_conf_file.py with the boolean room_param set to False. In this last case a basic
configuration file is created and can be manually improved/modified.


**Fields:**
* domain: the type of reconstruction considered: "time", "frequency" or "deconvolution"
* normalization: integer index giving the normalization used (0 for no normalization)
* max_order: the maximum order of the image sources generated by the simulation
* fs: sampling frequency in Hz
* fc: cutting frequency in Hz
* cutoff: maximum time in the RIR (in s)
* lambda: TV norm regularization parameter
* min_norm: minimal distance (in m) to the origin of a reconstructed source. In the case of a spherical antenna centered at (0,0,0)
should be superior to the antenna radius to reduce the impact of the singularities of the operator when the spike finding initialization is close to the microphones.
* ideal: use the ideal sinc operator if True, otherwise use pyroom acoustics simulations
* spherical_search: if True, use a sphere around a microphone as the search grid for spike finding initialization, otherwise use a full discretization
* dr, dphi, rmin, rmax: parametrize the grid search if spherical_search is False (dphi is in degrees)
* mic_size: scaling factor for the microphone antenna
* psnr: Peak Signal to Noise Ratio (db)
* max_iter: maximal number of iterations
* use_absorption: if True, use the absorption coefficients given in the room file, otherwise overwrite them with identical, highly reflecting walls
* deletion_tol: amplitude threshold under which a spike is considered negligible and is deleted
* start_cb: dictionary containing the parameters used to control the time segmentation of the RIR
Example: {"n_cut":10, "swap_frequency":20, "swap_factor":0.3}. Cut the RIR in 10, extend to the next segment if 20 iterations have passed or
if the residual has been reduced by a factor 0.3. Setting n_cut to 0 gets the default behavior (no segmentation).

**Additional argument "slide_opt" to control the sliding step:**

Should be a dictionary containing the options for the sliding step. If None: perform a full sliding
        at each step. Else: should contain a key "method", the associated value being in ["slide_once", "no_slide",
        "freeze"].
Behavior: 
* "slide_once" : skip the sliding step and perform a single sliding at the end
* "no_slide" : completely skip the sliding step
* "freeze" : the additional key "freeze_step" should be added. Check each spike every
        "freeze_step" iterations. If the spike has not moved sufficiently since the last check, the spike is frozen and
        is not allowed to slide in the next iterations.
        Additional option in that case: the key "resliding_step" allows for an additional periodic sliding step to be applied on
        every spike (including the frozen ones).
